// Package fs implements virtual file system access for compressed files.
package fs

import (
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// Broccoli is a virtual file system of brotli-compressed assets.
//
// This object is generated by broccoli the tool in the following
// fashion:
//
//     //go:generate broccoli src=asset1,asset2... -o filename -var br
//
type Broccoli struct {
	files     map[string]*File
	filePaths []string

	devMode bool
}

// Open opens the named file for reading. If successful, methods on
// the returned file can be used for reading.
func (br *Broccoli) Open(path string) (http.File, error) {
	path = normalize(path)

	if br.devMode {
		return os.Open(path)
	}

	if f, ok := br.files[path]; ok {
		if err := f.Open(); err != nil {
			return nil, err
		}
		return f, nil
	}

	return nil, os.ErrNotExist
}

// Stat returns a FileInfo describing the named file.
func (br *Broccoli) Stat(path string) (os.FileInfo, error) {
	path = normalize(path)

	if br.devMode {
		f, err := os.Open(path)
		if err != nil {
			return nil, err
		}

		return f.Stat()
	}

	if f, ok := br.files[path]; ok {
		return f, nil
	}

	return nil, os.ErrNotExist
}

// Walk walks the file tree rooted at root, calling walkFn for each file or
// directory in the tree, including root. All errors that arise visiting files
// and directories are filtered by walkFn. The files are walked in lexical
// order, which makes the output deterministic but means that for very
// large directories Walk can be inefficient.
// Walk does not follow symbolic links.
func (br *Broccoli) Walk(root string, walkFn filepath.WalkFunc) error {
	root = normalize(root)

	if br.devMode {
		return filepath.Walk(root, walkFn)
	}

	pos := sort.SearchStrings(br.filePaths, root)
	for ; pos < len(br.filePaths) && strings.HasPrefix(br.filePaths[pos], root); pos++ {
		f := br.files[br.filePaths[pos]]
		err := walkFn(f.Fpath, f, nil)
		if err != nil {
			return err
		}
	}

	return nil
}

// Development controls the development mode.
//
// If enabled, broccoli will use the local file system instead of
// the bundled set of files. This can be useful when doing rapid
// development cycles, when the local file system is available
// or you momentarily don't care about the contents of the bundle.
//
// 	if os.Getenv("PRODUCTION") == "" {
// 		br.Development(true)
// 	}
//
func (br *Broccoli) Development(mode bool) {
	br.devMode = mode
}

func normalize(path string) string {
	if strings.HasPrefix(path, "./") {
		return path[2:]
	}

	if strings.HasPrefix(path, "/") {
		return path[1:]
	}
	if strings.HasSuffix(path, "/") {
		return path[:len(path)-1]
	}

	return path
}
